<!doctype html>
<html data-bs-theme="dark">

<head>
    <title>
        Stateful Markup
    </title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <script src="../dist/StatefulMarkupClient.js"></script>
</head>

<script src="./components/dashboard.js"></script>
<script src="./components/footer.js"></script>
<!-- <script defer src="./index.js"></script> -->
<script defer src="../dist/StatefulMarkup.js"></script>

<link rel="stylesheet" href="./doc.css">


<!-- <body style="opacity: 0;"> -->

<body>
    <main class="d-flex flex-nowrap row-cols-2">
        <!-- Landing Cover -->
        <!-- Fix width of sidebar -->
        <div class="d-flex flex-column flex-shrink-0 p-3 text-bg-dark col-3" style="width: 280px;">
            <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-white text-decoration-none">
                <span class="fs-4">Sidebar</span>
            </a>
            <hr>
            <ul class="nav nav-pills flex-column mb-auto">
                <li class="nav-item">
                    <a href="#" class="nav-link active" aria-current="page">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Dashboard
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Orders
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Products
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Customers
                    </a>
                </li>
            </ul>
            <hr>
            <div class="dropdown">
                <a href="#" class="d-flex align-items-center text-white text-decoration-none dropdown-toggle"
                    data-bs-toggle="dropdown" aria-expanded="false">
                    <img src="https://github.com/mdo.png" alt="" width="32" height="32" class="rounded-circle me-2">
                    <strong>mdo</strong>
                </a>
                <ul class="dropdown-menu dropdown-menu-dark text-small shadow">
                    <li><a class="dropdown-item" href="#">New project...</a></li>
                    <li><a class="dropdown-item" href="#">Settings</a></li>
                    <li><a class="dropdown-item" href="#">Profile</a></li>
                    <li>
                        <hr class="dropdown-divider">
                    </li>
                    <li><a class="dropdown-item" href="#">Sign out</a></li>
                </ul>
            </div>
        </div>
        <div class="col-10">
            <div class="container justify-content-center align-items-center ">
                <div
                    class="position-relative my-5 p-5 text-center text-muted bg-body border border-success-subtle rounded-5">

                    <h1 class="text-body-emphasis display-1 lead">Documentation
                    </h1>
                    <div class="text-start">

                        <div class="display-5 py-4 heading">General Ideas</div>
                        Stateful Markup is a framework that does not work on existing popular territories. It is built with it's peculiar market in mind, and therefore, takes some unique paths to get there.
                        <br>
                        At a bird's eye view, these are roughly the stages it follows -
                        <li>Identifying DOM trees that have opted into reactivity</li>
                        <li>Cloning said trees, and making the clones be the ones getting displayed. The originals are just there for reference now.</li>
                        <li>Waiting for an update to occur to startup the Engine and Renderer.</li>
                        <li>Replacing the cloned tree's variables with the new values</li>
                        <li>Saving and reconciling state such as focused elements, text selected in a textbox and so on</li>
                        <li>Displaying the edited DOM tree by replacing the currently displayed DOM tree.</li>
                        <!-- Link to double buffering here -->


                        <div class="display-5 py-4 heading">Why do we need copies of original DOM tree?</div>
                        There are essentially two types of DOM trees needed for rendering, but we use three, and I'll explain why that is shortly. 
                        <br>
                        The Elements Tree - This is basically a reference DOM tree that the framework uses to keep track of where the variables are all located. If we did not save this, then after any variable was replaced, ie. '@name' with 'yash', next time @name had an update we wouldn't be able to find the @name variable in the DOM tree. We need to ensure we dont lose the positions of all variables and hence the reference tree is critical.
                        <br>
                        The Mirror & Shard - These are two copies of the DOM tree, the mirror is the one currently under display and the Shard is the one that gets edited whenever a new update occurs. The reason we keep two copies is for the purpose of double buffering so that the user has consistent view into the app.
                        <div class="display-5 py-4 heading">What is Double Buffering and why do we need it?</div>
                        Lets try to understand the need of double buffering with an example. <br>
                        Imagine a picture of a red house being displayed on an app you are browsing. The app receives a command to change the color of the walls of the house to green [just like we update the variables in SM]. Now, the app will slowly paint over the walls of the house, and during this time frame, you would be able to see half painted walls in red and green. Thats an inconsistent state.
                        <br> Instead of doing all that, what if I make a copy of the house ( I know that sounds ridiculous :) ) and once all the painting was done replaced the red house with the green one ? That would make it so that you would see the house in a complete state all the time rather in a weird half painted state.
                        <br>
                        This is what double buffering achieves. We keep two sets of DOM trees (houses in our previous analogy) and paint one of them when an update arrives, and replace the old DOM tree with the new one when the update has finished. This leads to a more consistent viewing experience.
                        <br>
                        Read more about it here: https://en.wikipedia.org/wiki/Multiple_buffering#External_links

                        <div class="display-5 py-4 heading">What are Subscribers?</div>
                        The framework works on a Pub-Sub like model. Subscribers are those HTML tags which contain the
                        special "_sm" class, which grants them visibility to the framework and
                        special powers like reactivity. Any subscriber provides these
                        special powers to its children elements too. Therefore, there can never be two elements
                        that contain this special class of which one is ancestor of the other, otherwise bad things
                        happen.

                        Any element that does not have an ancestor with this special class is in effect invisible to
                        this
                        framework and will never be modified by any state updates, components, constructs like if/for
                        and
                        so on.

                        The framework gets all subscribers once before the first render, and keeps track of them. If you
                        dynamically add / remove the _sm class using custom javascript, you will have to manually inform
                        the framework about it.
                        <br>
                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseOne" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseOne">
                                        Examples
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseOne" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>
                                        &lt;div class="_sm extra-class-one"> <div class="d-inline comment"><- This entire div, and anything within it is now changeable through the framework</div>
                                        <br>
                                        Some text, some &lt;div id="uid-1">...Nested Structure... &lt;/div> <div class="d-inline comment"><- But don't add the _sm tag here, the framework will break due to recursive updates.</div>
                                        <br>
                                        &lt;/div>
                                    </code>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseTwo">
                                        Improving performance
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Ideally, the subscribers of the framework should be as deep as possible for
                                        maximal performance. This is because with each change, the entire subscribed DOM
                                        tree changes, and hence if @vars exist only at a great depth, then their
                                        ancestors will
                                        get unnecessarily updated.
                                        <br>
                                        However, remember that premature optimization is often the bane of developer
                                        productivity. Stateful markup is highly performant usually, so you very very
                                        rarely need to do optimizations like the following:
                                        <br>
                                        <code>
                                            &lt;div class="parent <i>_sm</i>">Some content.&lt;div class="sibling-1">@var1&lt;/div>&lt;div class="sibling-2">@var2&lt;/div>&lt;/div>
                                        </code>
                                        <br>
                                        Can be optimized to ->
                                        <br>
                                        <code>
                                            &lt;div class="parent">Some Content.&lt;div class="sibling-1 <i>_sm</i>" class>@var1&lt;/div>&lt;div class="sibling-2 <i>_sm</i>">@var2&lt;/div>&lt;/div>
                                        </code>
                                        <br>
                                        Now the only div with class parent does not need to rebuild on change, only its
                                        children do.
                                    </div>
                                </div>
                            </div>
                        </div>
                        The framework creates transforms from the subscribers.

                        <div class="display-5 py-4 heading">What are Transforms?</div>
                        A transform is composed of 3 important parts. The element, the mirror and the shard. They are the crux of what converts the original DOM tree into a reactive display.
                        <div class="display-6 py-2 sub-heading">Elements</div>
                        Elements are original DOM nodes, as written by the site creator, completely untouched
                        by the framework. In effect they contain all the various special variables, components and
                        constructs in their textual form - @var, @@component, @_if .... etc.

                        The framework stores an unaltered copy of them, and then clones them to add reactivity to them,
                        and <b>only modifies and displays these clones.</b>
                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsehur" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsehur">
                                        Hide Until Ready
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsehur" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Before the JS has a chance to load, the user might see a momentary flash of elements that have not yet had the chance to get injected in their '@Var-name' form. To stop this, use <code>class="_sm_HideUntilReady" style="opacity: 0;"</code> either on the body(does not have to be a subscriber) to hide the entire body until ready or on each subscriber individually. 
                                    </div>
                                </div>
                            </div>
                        </div>
<!-- TODO: Double buffering explanation. -->
                        <div class="display-6 py-2 sub-heading">Mirrors</div>
                        Mirrors are the DOM trees that are currently being displayed to the user. When you push an
                        update,
                        and the display changes, that means a new mirror with the respective changes has replaced the
                        older DOM
                        tree in the document, which is why the changes can be seen.

                        <div class="display-6 py-2 sub-heading">Shards</div>
                        Shards are the future mirrors under construction. Every time an update is published, the
                        framework clones the original element and the injects the changes into the shard. Each shard
                        goes through many stages before it is ready to replace the mirror. These stages, in order are :
                        External Stateless Update, Value Injection, Construct Injection, Event Binding and then it is
                        finally ready to replace the current mirror.
                        (Read below to learn in detail about each stage.)
                        <br>
                        After the shards finish getting constructing, the mirrors then get replaced by the shards, and
                        the shards get nulled.

                        <div class="display-5 py-4 heading">What is Value Injection?</div>
                        Value Injection is the method by which framework really maintains reactivity, the process
                        involves updating the @vars present in a shard with the current values as published. The
                        _SM_ValueInjector class maintains a mapping of each variable and their value, which gets updated
                        with each update/publish call.

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsevi" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsevi">
                                        Components through Value Injection
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsevi" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        If you think about it, the markup injected in a component is similar to a any
                                        data being injected through an <code>@var</code>. So, when a component is
                                        registered and used, the framework publishes a variable with
                                        <code>var = @component-name</code> and <code>value = template </code>of the
                                        component.
                                        <br>
                                        Ofcourse, components also have listeners and events associated with them, which
                                        are handled as normal.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-4 heading">What are Constructs?</div>
                        Constructs are an abstraction that support usage functions common in other functions and help
                        write shorter, less verbose code. There are 2 basic constructs : If and For. The If construct
                        conditionally renders the DOM elements inside if it evaluates to true. The For construct expands
                        a list shared in the header, and displays it as the markup indicates.

                        <div class="display-5 py-4 heading">What is Construct Injection?</div>
                        Construct Injection is the method by which @_for and @_if constructs really come alive. The
                        framework evaluates the array/condition passed into the header of these constructs and
                        accordingly expands/displays the body of the construct. The body of the construct is marked by
                        two special brackets- @{ and }@ to indicate their start and end.

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseci" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseci">
                                        Creating new Constructs
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseci" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Creating new constructs to suit you use case is very simple. The code follows
                                        basically two stages:
                                        <br>
                                        Finding the markers : Markers are a way to indicate to the framework that a
                                        construct is present in the markup. There are 3 marker -
                                        <code>'@_', '@{' </code>and <code>'}@'</code>. The @_ follows a name which is
                                        the type of construct. Then a pair of brackets follow, containing the header,
                                        like a list or a variable. @{ and }@ contain the body of the construct. This
                                        will typically be some type of markup that gets modified and displayed by the
                                        construct, but can really be anything you wish.
                                        <br>
                                        The second stage is executing the construct. The code grabs the construct type
                                        and then switches to a function that knows how to handle it.
                                        <br>
                                        <br>
                                        Constructs are <code>best used when there is a
                                            particular pattern that you often need to execute in code. The most common
                                            ones I felt were useful was conditional rendering and list expansion, which
                                            is why I built those.</code>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-2 heading">What is Event Binding?</div>
                        When a DOM tree is cloned, the resulting clone tree does not keep any event listeners attached
                        to the original tree. So to keep the event listeners attached to the mirrors, we use the
                        addEventListener function provided by the framework and register the event listeners there, so
                        that with each update we re-add the event listeners to each shard.

                        <div class="display-5 py-4 heading">Time to update Transforms!</div>
                        Now that all the stages are over, we replace the mirrors currently on display with the
                        corresponding shards.

                        <!-- An example gif / text would be nice. -->

                        <div class="display-5 py-4 heading">Batched Rendering</div>
                        Batched rendering is the a way of increasing performance and taxing user devices less. When an
                        update is performed, the framework waits for a few milliseconds hoping for some other updates to
                        also come, (this is often true if some updates happen together, such as as sign-out UI change
                        also triggering some changes in the nav-bar etc) and then performs the updates all together.
                        This saves some processing power and can lead to a smoother UI. The wait time is always supposed
                        to be low enough, the the user does not notice this delay, typically 16ms(60 fps) or 33ms(30
                        fps).

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsebr" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsebr">
                                        Tuning the Frame-Rate
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsebr" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        By virtue of the fact that Stateful Markup borrows some of its architectural
                                        design from game engines, it is able to easily switch up the frame rate, ie. the
                                        time between each batched render.
                                        <br>
                                        To toggle this, use the following code, and refresh the page:
                                        <br>
                                        <code>StatefulMarkupConfig.TARGET_FRAMERATE = 1</code>
                                        <br>
                                        Now, each update will take a second to show up. This can be useful to tune
                                        according to your users needs if they have slower/faster devices, from 1 FPS to
                                        120 or more.
                                        <br>
                                        <img src="assets/1FpsDemoGif.gif" alt="Rendering at 1FPS, Batched Render."
                                            height="300px" width="700px">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-2 heading">What are Persistent Updates?</div>
                        Stateful Markup offers publishing updates to your local storage so that even when your website
                        is closed and reopened later some state can be preserved. For example if the user was logged in,
                        you can simply save their user name and display it automatically when they re-open your website.
                        <!-- Simple ui here to show a line of the function. -->

                        <div class="display-5 py-4 heading">What do you mean by Wasteless DOM Updates?</div>
                        When an update does not cause any noticeable change in the UI, the framework smartly discards
                        creating a shard and updating the mirror. For example publishing a @variable that exists in only
                        a small set of DOM trees, causes only these DOM trees to get updated.
                        This allows for performant rendering, especially with larger DOM trees.

                        <!-- Improve Content 
                        1. Opt in using _sm-->
                        <div class="display-5 py-4 heading">Orthogonally Designed</div>
                        Orthogonal design is a philosophy of creating tools that can layer on top of existing processes,
                        and dont need the creator to change their pre-existing codebase to use them. They simply add
                        features, and dont impinge other functions. These can be dropped onto an older project and
                        simply work, without causing trouble with the other libraries, tools and other frameworks you
                        might be using.
                        <br>
                        Stateful Markup tries to be very orthogonal, letting you keep as much of your code as
                        possible. If you were manually manipulating the DOM tree through external JS, the framework
                        provides a convenient wrapper a one line wrapper so that you can keep that. If you were using
                        custom event listeners, the addEventListener allows you to keep the code you had already
                        written.
                        <br>
                        The variables/constructs are named starting with '@/@_' to minimize chances of the framework
                        misidentifying normal text. Similarly, the _sm class and the every function in the
                        StatefulMarkup.js file starts with _SM_ prefix, so that it does not interfere with existing
                        libraries.
                        <br>
                        In short, framework tries to assume as little as possible about the existing DOM tree, or
                        existing JS, so that whatever be the project, a minimal amount of changes are required.

                        <div class="display-5 py-4 heading">Components</div>
                        When I designed Stateful Markup, a useful feature that could get neatly implemented was
                        Components.
                        Components are a nice coupling of
                        They can offer a greatly ergonomic experience & extensibility in your website (with a small
                        tradeoff in performance).


                        They allow ma   rkup and event listeners for the footer, the nav-bar, dashboard components and
                        other oft-repeated items to be written once, imported anywhere, leading to a cleaner code-base.
                        They also couple the state, events handling and the markup together, so there is just a single
                        source of truth for such stuff.

                        Remember that state is global, so be descriptive in your variable names!

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseTwo">
                                        Example component- Penguin Launcher
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>const DashboardComponent = { <div class="d-inline comment"><- Declare a component to register.</div>
                                            <br>
                                            name: 'Dashboard', <div class="d-inline comment"><- Use the string @@Dashboard in any subscribed class to display</div>
                                                <br>
                                            template: ` <div class="d-inline comment"><- Use the string @@Dashboard in any subscribed class to display the following instead</div>
                                            <br>
                                            &lt;div id="dash" class="container-fluid h-100 justify-content-start rounded">
                                            <br>
                                            &lt;div class="display-6 p-4 text-danger">Super Secret Dashboard&lt;/div>
                                            <br>
                                            &lt;div class="lead fs-4 py-1">Welcome @Suffix&lt;/div>
                                            <br>
                                            &lt;button class="btn btn-outline-success text-start fw-semibold fs-6">Launch Penguins into North Korea&lt;/button>
                                            <br>
                                            &lt;/div>
                                            <br>
                                            `,
                                            <br>
                                            eventListeners: [{ <div class="d-inline comment"><- Pass an array of event listeners to execute, typically scoped to work only on this component</div>
                                                <br>
                                                selector: '#dash .btn', onEvent: 'click', callback: () => {
                                                    <br>
                                                    alert('Penguins launched!')
                                                    <br>
                                                }
                                                <br>
                                            }],
                                            <br>
                                            events: [] <div class="d-inline comment"><- Pass in a set of events, that get executed as soon as the component is registered. Note: They use the publish API, instead of the update API.</div>
                                            <br>
                                        }
                                        <br>
                                        <br>
                                        
                                        StatefulMarkupClient.registerComponent(DashboardComponent) <div class="d-inline comment"><- Registering a component makes it visible to the framework. An unregistered component is unable to get injected.</div>
                                    `</code>


                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- TODO: Write functions like publish and external dom manip, and give examples. -->
                        <div class="display-5 py-2 heading">Reconciliation Phase</div>
                        When a DOM tree is cloned, it does not preserve certain states like the focused element, a
                        checked box or radio button, or the text selected in an input box. These properties have to be
                        preserved separately. For this, the framework calls a saveState function, that reads these
                        special properties, and after the transforms get updated, it reconciles these saved properties
                        back to the DOM tree.
                        <br>
                        Right now the save and reconcile process is still under work. <div class="cond-2 fw-bold">The goal is to build a generic
                        method of saving and reconciling that does not require any user input, instead right now what we
                        have in working is are different types of reconciliations on a per-case basis </div>(ie. different
                        functions for inputs, checkboxes, radio-groups etc).
                        <br>
                        The code to build such functions is pretty simple, I've built one to preserve focus for text
                        input elements.
                        I welcome and appreciate any effort to help build such plugins for supporting different input
                        types.
                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseps" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseps">
                                        Example Plugin Code
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseps" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>static saveInputState(evt: ReconcilliationEvent) { <div class="d-inline comment"><- The evt contains the a selector to indicate which DOM element we are saving state of.</div>
                                            <br>
                                            let currentState: ReconcilliationEvent = { on: 'input-text', selector: evt.selector }
                                            <br>
                                            let selector = evt.selector
                                            <br>
                                            let element = document.querySelector(selector) <div class="d-inline comment"><- Get the to be saved element.</div>
                                            <br>
                                            
                                            if (element === null)
                                            <br>
                                            return _SM_Log.log(2, 'Save state element not found, selector: ' + selector)
                                            <br>
                                            <div class="d-inline comment"><- Now we are going to save the properties we wish to preserve like focus, and text selected</div>
                                            currentState.wasFocused = (document.activeElement === element) + '' <div class="d-inline comment"><- Checks if this element was focused on.</div>
                                            <br>
                                            currentState.selectionStart = element.selectionStart <div class="d-inline comment"><- Finds the start of text selection, ie. cursor start</div>
                                            <br>
                                            currentState.selectionEnd = element.selectionEnd <div class="d-inline comment"><- Similar to above</div>
                                            <br>
                                            this._savedStates.push(currentState) <div class="d-inline comment"><- Put the saved properties for reconciling later.</div>
                                            <br>
                                        }
                                        <br>
                                        
                                        <br>
                                        static reconcileInputState(save: ReconcilliationEvent) { <div class="d-inline comment"><- save is one of the possibly many saved elements reconciled.</div>
                                            <br>
                                            
                                            let element = document.querySelector(save.selector) <div class="d-inline comment"><- Extract the element from the new DOM tree.</div>
                                            <br>
                                            
                                            if (element === null)
                                            <br>
                                            return _SM_Log.log(2, 'Cannot find element to reconcile - ' + save.selector)
                                            <br>
                                            
                                            if (save.wasFocused === 'true') {
                                                <br>
                                                (element as HTMLElement).focus()
                                                <br>
                                            }
                                            <br>
                                            <div class="d-inline comment"><- Re-add focus if it was focused before the render happened.</div>
                                            
                                            element.setSelectionRange(save.selectionStart, save.selectionEnd)
                                            <br>

                                        }
                                        <br>
                                        <br>

                                        While this works fine, its not very scalable to have to write such reconcilliation events for each type of DOM element you wish to preserve. 
                                    </code>
                                    </div>
                                </div>
                            </div>
                        </div>
                        Depending on your use-case, I would recommend not adding an '_sm' class to any ancestor of a form containing radio-groups, checkboxes etc unless you are sure they are supported. <div class="highlight-inline fw-bold">Whats great is that since Stateful Markup is opt-in for any DOM tree, you can still use anywhere else on the page.</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
</body>

</html>