<!doctype html>
<html data-bs-theme="dark">

<head>
    <title>
        Stateful Markup
    </title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <script src="../dist/StatefulMarkupClient.js"></script>
    <script src="../dist/StatefulMarkupDebugger.js"></script>
</head>

<script src="./components/dashboard.js"></script>
<script src="./components/footer.js"></script>
<!-- <script defer src="./index.js"></script> -->
<script defer src="../dist/StatefulMarkup.js"></script>

<link rel="stylesheet" href="./doc.css">


<!-- <body style="opacity: 0;"> -->

<body>
    <main class="d-flex flex-nowrap row-cols-2">
        <!-- Landing Cover -->
        <!-- Fix width of sidebar -->
        <div class="position-sticky top-0 d-flex flex-column flex-shrink-0 p-3 text-bg-dark col-3"
            style="width: 280px; height:fit-content">
            <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-white text-decoration-none">
                <span class="fs-2 cond-2">Documentation</span>
            </a>
            <hr>
            <ul class="nav nav-pills flex-column mb-auto fs-4 lead">
                <li class="nav-item">
                    <a href="#" class="nav-link active" aria-current="page">
                        Overview
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Opting In With Subs
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Transformation & Buffering
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Engine Phases
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Components
                    </a>
                </li>
                <li>
                    <a href="#" class="nav-link text-white">
                        Reconciliation <div class="cond-2 text-danger"> !</div>
                    </a>
                </li>
                <!-- <li>
                    <a href="#" class="nav-link text-white">
                        Debugger
                    </a>
                </li> -->
                <li>
                    <a href="#" class="nav-link text-white">
                        Common Mistakes & Debugging
                    </a>
                </li>
            </ul>
            <hr>
            <div class="dropdown">
                <a href="../index.html" class="d-flex align-items-center text-white text-decoration-none">
                    <div class="fs-5 highlight-inline">Go to Homepage</div>
                </a>
            </div>
        </div>
        <div class="col-10">
            <div class="container justify-content-center align-items-center ">
                <!-- <div
                    class="position-relative my-5 p-5 text-center text-muted bg-body border border-success-subtle rounded-5"> -->
                <div class="position-relative my-3 p-5 text-center text-muted bg-body">
                    <h1 class="text-body-emphasis display-1 lead">Documentation
                    </h1>
                    <div class="text-start">

                        <div class="display-5 py-4 heading">General Ideas</div>
                        <p>
                            Stateful Markup is a framework that is designed to integrate and supercharge existing large
                            or new vanilla js projects.
                            <br>
                            To that effect, it tries to do a select few really common things, but do them well.
                            <li>State and Reactivity</li>
                            <li>Components</li>
                            <li>Performant Batched Rendering</li>
                            <li>Easy extensibility (Plugin system)</li>
                            <br>
                        <div class="cond-2">These are probably some of the major reasons why some developers are forced
                            to migrate to frameworks, and I hope having such a direct way to get these select features
                            makes for a better DX if that's you.
                        </div>
                        <br>
                        </p>
                        <p>
                            At a high level, the framework progresses through the following stages:
                        </p>
                        <ul>
                            <li>Identifying DOM trees that have opted into reactivity/components etc</li>
                            <li>Cloning said trees, with the clones being the ones displayed; the originals serve as
                                references</li>
                            <li>Waiting for an update to trigger the startup of the Engine and Renderer</li>
                            <li>Replacing the cloned tree's variables with the new values</li>
                            <li>Saving and reconciling state, such as focused elements and selected text in a textbox
                            </li>
                            <li>Displaying the edited DOM tree by replacing the currently displayed DOM tree</li>
                        </ul>
                        <br>
                        If the results of your code are not what you expect, I'd recommend using additional debug client
                        script to help identify any mistakes. It helpfully tests for many common issues.

                        <div class="display-5 py-4 heading">Overview of the Phases</div>
                        <img src="assets/renderphases.png" width="90%" class="img py-3">
                        <br>
                        A high level overview is as follows (Detailed description is provided further below) :
                        <br>

                        <li>Stateless Update: Updates the reference DOM if needed.</li>
                        <li>Value Injection: This phase replaces all the @Var with their values</li>
                        <li>Construct Injection: Expands all @_for/@_if or any construct plugins</li>
                        <li>Event Binding: Re-attaches all event listeners to DOM</li>
                        <li>Reconciliation: Re-adds context not captured in markup, (eg. focus)</li>
                        <div class="accordion pt-3 pb-2" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseoverview" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseoverview">
                                        Difference b/w first and subsequent renders
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseoverview" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Before the engine is loaded, we simply go
                                        through all the phases since we aren't sure which are not needed.
                                        <br>
                                        But once the engine has loaded, we know of all the events that have occurred
                                        since and can intelligently optimize and skip certain stages.
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="display-5 py-4 heading">Why do we need copies of the original DOM tree?</div>
                        <p>
                            Three types of DOM trees are required for rendering, and here's why:
                        </p>
                        <p>
                            <strong>The Elements Tree:</strong> This reference DOM tree tracks the locations of
                            variables. Without it, after any variable replacement (e.g., '@name' with 'yash'), the
                            framework would lose track of the @name variable in the DOM tree.
                        </p>
                        <p>
                            <strong>The Mirror & Shard:</strong> These are two copies of the DOM tree, with the mirror
                            currently under display, and the shard edited with each new update. Keeping two copies
                            facilitates double buffering, ensuring a consistent user view into the app.
                        </p>

                        <div class="display-5 py-4 heading">Benefits of Double Buffering</div>
                        <p>
                            Let's grasp the need for double buffering through an example. Imagine a red house displayed
                            on an app. Upon receiving a command to change the wall color to green, the app would slowly
                            paint over the walls, resulting in an inconsistent half-painted state of red and green.
                            Instead, with double buffering, we maintain two sets of DOM trees, painting one while the
                            other is displayed. This leads to a more consistent viewing experience.
                        </p>
                        <p>
                            Read more about it <a
                                href="https://en.wikipedia.org/wiki/Multiple_buffering#External_links">here</a>.
                        </p>

                        <div class="display-5 py-4 heading">What are Subscribers?</div>
                        <p>
                            Subscribers are the main measure with which we can enforce the opt-in nature of the
                            framework.
                            Subscribers are HTML tags containing the special
                            "_sm" class, granting them visibility and reactivity powers. Any subscriber extends these
                            powers to its children elements.
                            <br>
                            Note that a subscriber cannot have another subscriber within it, since the ancestor will
                            take complete control over the rendering.
                        </p>
                        <p>
                            Any element lacking an ancestor with this special class is invisible to the framework and
                            remains unaffected by state updates, components, or constructs like if/for.
                        </p>
                        <p>
                            The framework captures all subscribers before the first render, keeping track of them. If
                            you dynamically add/remove the "_sm" class using custom JavaScript, manual notification to
                            the framework is necessary.
                        </p>
                        <div class="accordion pt-1 pb-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseOne" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseOne">
                                        Examples
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseOne" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>
                                        &lt;div class="_sm extra-class-one"> <div class="d-inline comment"><- This entire div, and anything within it is now changeable through the framework</div>
                                        <br>
                                        Some text, some &lt;div id="uid-1">...Nested Structure... &lt;/div> <div class="d-inline comment"><- But don't add the _sm tag here, the framework will break due to recursive updates.</div>
                                        <br>
                                        &lt;/div>
                                    </code>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseTwo">
                                        Improving performance
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Ideally, the subscribers of the framework should be as deep as possible for
                                        maximal performance. This is because with each change, the entire subscribed DOM
                                        tree changes. If @vars exist only at a great depth, then their ancestors will
                                        get unnecessarily updated.
                                        <br>
                                        However, remember that premature optimization is often the bane of developer
                                        productivity. Stateful markup is highly performant usually, so you very rarely
                                        need to do optimizations like the following:
                                        <br>
                                        <code>
                                            &lt;div class="parent <i>_sm</i>">Some content.&lt;div class="sibling-1">@var1&lt;/div>&lt;div class="sibling-2">@var2&lt;/div>&lt;/div>
                                        </code>
                                        <br>
                                        Can be optimized to ->
                                        <br>
                                        <code>
                                            &lt;div class="parent">Some Content.&lt;div class="sibling-1 <i>_sm</i>" class>@var1&lt;/div>&lt;div class="sibling-2 <i>_sm</i>">@var2&lt;/div>&lt;/div>
                                        </code>
                                        <br>
                                        Now the only div with class "parent" does not need to rebuild on change; only
                                        its children do.
                                    </div>

                                </div>
                            </div>
                        </div>
                        The framework creates transforms from the subscribers.

                        <div class="display-5 py-4 heading">What are Transforms?</div>
                        <p>
                            A transform is comprised of three crucial parts: the element, the mirror, and the shard.
                            These elements form the essence of what converts the original DOM tree into a reactive
                            display.
                        </p>

                        <div class="display-6 py-2 sub-heading">Elements</div>
                        <p>
                            Elements are the original DOM nodes as authored by the site creator, remaining entirely
                            untouched by the framework. They encapsulate various special variables, components, and
                            constructs in their textual form - such as @var, @@component, @_if, and more.
                        </p>
                        <p>
                            The framework preserves an unaltered copy of them, cloning them to introduce reactivity.
                            <strong>It only modifies and displays these clones.</strong>
                        </p>

                        <div class="accordion pt-1 pb-2" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsehur" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsehur">
                                        Hide Until Ready
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsehur" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Before the JS has a chance to load, the user might see a momentary flash of
                                        elements that have not yet had the chance to get injected in their '@Var-name'
                                        form. To stop this, use
                                        <code>class="_sm_HideUntilReady" style="opacity: 0;"</code> either on the body
                                        (does not have to be a subscriber) to hide the entire body until ready or on
                                        each subscriber individually.
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- TODO: Double buffering explanation. -->

                        <div class="display-6 py-2 sub-heading">Mirrors (aka Front Buffer)</div>
                        <p>
                            Mirrors are the DOM trees currently being displayed to the user. When you push an update and
                            the display changes, a new mirror with the respective changes replaces the older DOM tree in
                            the document, explaining why the changes become visible.
                        </p>

                        <div class="display-6 py-2 sub-heading">Shards (aka Back Buffer)</div>
                        <p>
                            Shards represent the future mirrors under construction. Upon each update publication, the
                            framework clones the original element and injects the changes into the shard. Each shard
                            goes through multiple stages before it is ready to replace the mirror. These stages, in
                            order, include External Stateless Update, Value Injection, Construct Injection, Event
                            Binding, and finally being prepared to replace the current mirror.
                            <br>
                            After the shards finish construction, the mirrors are replaced by the shards, and then the
                            shards are nulled.
                        </p>

                        <div class="display-5 py-4 heading">What is Value Injection?</div>
                        <p>
                            Value Injection is the method through which the framework truly maintains reactivity. The
                            process involves updating the @vars present in a shard with the current values as published.
                            The _SM_ValueInjector class manages a mapping of each variable and its value, which gets
                            updated with each update/publish call.
                        </p>

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsevi" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsevi">
                                        Inserting Component markup
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsevi" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        When you consider it, the markup injected in a component is similar to any data
                                        being injected through an <code>@var</code>. So, when a component is registered
                                        and used, the framework publishes a variable with
                                        <code>var = @component-name</code> and <code>value = template</code> of the
                                        component.
                                        <br>
                                        <br>
                                        Of course, components also have listeners and events associated with them, which
                                        go through the normal event system.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-4 heading">What are Constructs?</div>
                        <p>
                            Constructs are abstractions that support the usage of functions common in other functions,
                            helping write shorter, less verbose code. There are two basic constructs: If and For. The If
                            construct conditionally renders the DOM elements inside if it evaluates to true. The For
                            construct expands a list shared in the header and displays it as the markup indicates.
                        </p>

                        <div class="display-5 py-4 heading">What is Construct Injection?</div>
                        <p>
                            Construct Injection is the method through which @_for and @_if constructs come alive.
                            <br>
                            The framework expands body (surrounded by @{ and }@) according to the type of construct and
                            the condition of the header.
                        </p>


                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseci" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseci">
                                        Creating new Constructs
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseci" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        Creating new constructs to suit your use case is straightforward and follows
                                        basically two stages:
                                        <br>
                                        <br>
                                        <strong>Finding the markers:</strong> Markers are a way to indicate to the
                                        framework that a construct is present in the markup. There are three markers -
                                        <code>'@_', '@{'</code>, and <code>'}@'</code>. The @_ follows a name which is
                                        the type of construct. Then a pair of brackets follow, containing the header,
                                        like a list or a variable. @{ and }@ contain the body of the construct. This
                                        will typically be some type of markup that gets modified and displayed by the
                                        construct, but can really be anything you wish.
                                        <br>
                                        <br>
                                        <strong>The second stage is executing the construct:</strong> The code grabs the
                                        construct type and then switches to a function that knows how to handle it.
                                        There is complete freedom in how the function works, so build your own if you
                                        wish!
                                        <br>
                                        <br>
                                        Constructs are
                                        <code>best used when there is a particular pattern that you often need to execute in code. The most common ones I felt were useful were conditional rendering and list expansion, which is why I built those.</code>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-4 heading">What is Event Binding?</div>
                        <p>
                            When a DOM tree is cloned, the resulting clone tree does not keep any event listeners
                            attached to the original tree. So, to retain the event listeners attached to the mirrors, we
                            use the addEventListener function provided by the framework and register the event listeners
                            there. This way, with each update, we re-add the event listeners to each shard.
                        </p>

                        <div class="display-5 py-4 heading">Time to update Transforms!</div>
                        <p>
                            Now that all the stages are over, we replace the mirrors currently on display with the
                            corresponding shards.
                        </p>

                        <!-- An example gif / text would be nice. -->

                        <div class="display-5 py-4 heading">Batched Rendering</div>
                        <p>
                            Batched rendering is a method to increase performance and reduce the load on user devices.
                            When an update is performed, the framework waits for a few milliseconds, hoping for other
                            updates to also arrive (common when some updates happen together, such as a sign-out UI
                            change triggering changes in the nav-bar, etc.), and then performs the updates collectively.
                            This optimization saves processing power and can result in a smoother UI. The wait time is
                            generally kept low enough so that users do not notice the delay, typically 16ms (60 fps) or
                            33ms (30 fps).
                        </p>

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsebr" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsebr">
                                        Tuning the Frame-Rate
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsebr" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        By borrowing architectural design from game engines, Stateful Markup easily
                                        allows switching up the frame rate, i.e., the time between each batched render.
                                        <br>
                                        To edit this, use the following code and refresh the page:
                                        <br>
                                        <br>
                                        <code>StatefulMarkupConfig.TARGET_FRAMERATE = 1 //Or your desired value.</code>
                                        <br>
                                        <br>
                                        Now, each update will take a second to show up. This can be useful to tune
                                        according to your users' needs, especially if they have slower/faster devices,
                                        ranging from 1 FPS to 120 or more.
                                        <br>
                                        <img src="assets/1FpsDemoGif.gif" alt="Rendering at 1FPS, Batched Render."
                                            height="300px" width="700px">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="display-5 py-4 heading">Persistent Updates</div>
                        <p>
                            Stateful Markup offers the capability to publish updates to local storage, allowing the
                            preservation of some state even when your website is closed and reopened later.
                            <br>
                            The persisted updates are reloaded as the first events automatically when the page is
                            refreshed.
                            <br>
                            Examples -
                            <br>
                            <li>Saving theme, dark-mode or settings preferences</li>
                            <li>Setting default values to @variables</li>
                        </p>

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapsepu" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapsepu">
                                        Example
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapsepu" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>SM.publish({ type: 'update_p', var: 'Variable', val: 'Init Value' })</code>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Simple ui here to show a line of the function. -->

                        <div class="display-5 py-4 heading">Selective DOM Tree Updates</div>
                        <p>
                            The framework has the ability to intelligently discard the creation
                            of a shard and updating the mirror when an update doesn't cause any noticeable change in the
                            UI. For example, publishing a @variable that exists in only a small set of DOM trees results
                            in only these specific DOM trees getting updated. This approach allows for performant
                            rendering, particularly with larger DOM trees.
                        </p>

                        <!-- Improve Content 
1. Opt in using _sm-->
                        <div class="display-5 py-4 heading">Orthogonally Crafted for Seamless Integration</div>
                        <p>
                        <p>
                            Stateful Markup embraces the power of orthogonal design, seamlessly integrating with your
                            current processes and codebase. Meticulously crafted to enhance functionality without
                            imposing changes, our framework ensures effortless coexistence with your existing libraries,
                            tools, and frameworks.
                        </p>

                        <p>
                            Benefit from high orthogonality as Stateful Markup empowers you to preserve the integrity of
                            your code. Whether you manipulate the DOM tree through external JS or utilize custom event
                            listeners, our framework provides smooth integration with convenient one-line wrappers and
                            the addEventListener function.
                        </p>

                        <p>
                            To prevent misidentification, variables and constructs bear the '@/@_' prefix, while the _sm
                            class and every function in the StatefulMarkup.js file feature the _SM_ prefix. This
                            thoughtful naming strategy guarantees a non-intrusive coexistence with your current
                            libraries.
                        </p>

                        <p>
                            In essence, Stateful Markup makes minimal assumptions about your DOM tree or JS code,
                            requiring only nominal changes. Regardless of project complexity, our framework ensures a
                            harmonious integration process, minimizing disruptions to your established development
                            practices.
                        </p>



                        <!-- Introduction -->

                        <!-- Benefits List -->
                        <!-- FIXME: Add it to key benefits at the end. -->
                        <h2>Key Benefits</h2>
                        <ul>
                            <li><b>Effortless Integration:</b> Stateful Markup effortlessly integrates into diverse
                                projects, minimizing the need for extensive modifications to your existing codebase.
                                Enjoy a smooth adoption process and accelerated development workflow.</li>

                            <li><b>Code Preservation:</b> Preserve your current coding styles and practices. Whether
                                you've been manually manipulating the DOM tree or implementing custom event listeners,
                                Stateful Markup respects and preserves these functionalities with minimal intervention.
                            </li>

                            <li><b>Enhanced Collaboration:</b> Foster collaboration among developers with varying coding
                                preferences and styles. The framework's non-intrusive integration allows team members to
                                contribute without major disruptions to the existing codebase.</li>

                            <li><b>Minimized Learning Curve:</b> Seamlessly incorporate Stateful Markup without a steep
                                learning curve. The framework's minimal assumptions about the existing DOM tree and
                                JavaScript code ensure a gentle transition, reducing the time needed for adaptation.
                            </li>

                            <li><b>Adaptable to Diverse Projects:</b> Stateful Markup's orthogonality extends its
                                applicability to a wide range of projects. Whether you're working on a small-scale
                                website or a complex web application, the framework's flexibility accommodates different
                                project sizes and requirements.</li>

                            <li><b>Reduced Maintenance Overhead:</b> By preserving the integrity of your codebase,
                                Stateful Markup diminishes potential maintenance overhead associated with extensive
                                modifications. Adopt the framework confidently, knowing that your existing code remains
                                intact and functional.</li>
                        </ul>

                        <!-- Conclusion -->
                        <p>
                            In summary, the orthogonal design philosophy embedded in Stateful Markup simplifies
                            integration, enhances collaboration, reduces the learning curve, and ensures adaptability
                            across diverse projects, all while preserving the integrity of your existing codebase.
                        </p>

                        </p>

                        <div class="display-5 py-4 heading">Components</div>
                        <p>
                            When designing Stateful Markup, a valuable feature that could be neatly implemented was
                            Components.
                            Components are a powerful coupling of various elements, providing an ergonomic experience
                            and extensibility to your website, albeit with a small tradeoff in performance.

                            They allow you to write markup and event listeners for frequently repeated items, such as
                            the footer, nav-bar, dashboard components, etc., only once. This leads to a cleaner and more
                            maintainable codebase. Components also consolidate state, event handling, and markup,
                            providing a single source of truth for such elements.

                            Remember that state is global, so it's important to avoid collisions in your variable names!
                        </p>


                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseTwo">
                                        Example component- Penguin Launcher
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>const DashboardComponent = { <div class="d-inline comment"><- Declare a component to register.</div>
                                            <br>
                                            name: 'Dashboard', <div class="d-inline comment"><- Use the string @@Dashboard in any subscribed class to display</div>
                                                <br>
                                            template: ` <div class="d-inline comment"><- Use the string @@Dashboard in any subscribed class to display the following instead</div>
                                            <br>
                                            &lt;div id="dash" class="container-fluid h-100 justify-content-start rounded">
                                            <br>
                                            &lt;div class="display-6 p-4 text-danger">Super Secret Dashboard&lt;/div>
                                            <br>
                                            &lt;div class="lead fs-4 py-1">Welcome @Suffix&lt;/div>
                                            <br>
                                            &lt;button class="btn btn-outline-success text-start fw-semibold fs-6">Launch Penguins into North Korea&lt;/button>
                                            <br>
                                            &lt;/div>
                                            <br>
                                            `,
                                            <br>
                                            eventListeners: [{ <div class="d-inline comment"><- Pass an array of event listeners to execute, typically scoped to work only on this component</div>
                                                <br>
                                                selector: '#dash .btn', onEvent: 'click', callback: () => {
                                                    <br>
                                                    alert('Penguins launched!')
                                                    <br>
                                                }
                                                <br>
                                            }],
                                            <br>
                                            events: [] <div class="d-inline comment"><- Pass in a set of events, that get executed as soon as the component is registered. Note: They use the publish API, instead of the update API.</div>
                                            <br>
                                        }
                                        <br>
                                        <br>
                                        
                                        StatefulMarkupClient.registerComponent(DashboardComponent) <div class="d-inline comment"><- Registering a component makes it visible to the framework. An unregistered component is unable to get injected.</div>
                                    `</code>


                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- TODO: Write functions like publish and external dom manip, and give examples. -->
                        <div class="display-5 py-4 heading">Reconciliation Phase <strong class="text-danger fs-3">
                                WIP</strong>
                        </div>
                        <p>
                            When a DOM tree is cloned, it does not preserve certain states like the focused element, a
                            checked box or radio button, or the text selected in an input box. These properties have to
                            be preserved separately. For this, the framework calls a saveState function that reads these
                            special properties. After the transforms get updated, it reconciles these saved properties
                            back to the DOM tree.
                            <br>
                            Currently, the save and reconcile process is still under work. <span
                                class="cond-2 fw-bold">The goal is to build a generic method of saving and reconciling
                                that does not require any user input. However, at the moment, different types of
                                reconciliations are implemented on a per-case basis </span>(i.e., different functions
                            for inputs, checkboxes, radio-groups, etc.).
                            <br>
                            The code to build such functions is relatively simple; I've created one to preserve focus
                            for text input elements. I welcome and appreciate any effort to help build plugins for
                            supporting different input types.
                        </p>

                        <div class="accordion py-3" id="accordionPanelsStayOpenExample">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#panelsStayOpen-collapseps" aria-expanded="false"
                                        aria-controls="panelsStayOpen-collapseps">
                                        Example Plugin Code
                                    </button>
                                </h2>
                                <div id="panelsStayOpen-collapseps" class="accordion-collapse collapse">
                                    <div class="accordion-body">
                                        <code>static saveInputState(evt: ReconcilliationEvent) { <div class="d-inline comment"><- The evt contains the a selector to indicate which DOM element we are saving state of.</div>
                                            <br>
                                            let currentState: ReconcilliationEvent = { on: 'input-text', selector: evt.selector }
                                            <br>
                                            let selector = evt.selector
                                            <br>
                                            let element = document.querySelector(selector) <div class="d-inline comment"><- Get the to be saved element.</div>
                                            <br>
                                            
                                            if (element === null)
                                            <br>
                                            return _SM_Log.log(2, 'Save state element not found, selector: ' + selector)
                                            <br>
                                            <div class="d-inline comment"><- Now we are going to save the properties we wish to preserve like focus, and text selected</div>
                                            currentState.wasFocused = (document.activeElement === element) + '' <div class="d-inline comment"><- Checks if this element was focused on.</div>
                                            <br>
                                            currentState.selectionStart = element.selectionStart <div class="d-inline comment"><- Finds the start of text selection, ie. cursor start</div>
                                            <br>
                                            currentState.selectionEnd = element.selectionEnd <div class="d-inline comment"><- Similar to above</div>
                                            <br>
                                            this._savedStates.push(currentState) <div class="d-inline comment"><- Put the saved properties for reconciling later.</div>
                                            <br>
                                        }
                                        <br>
                                        
                                        <br>
                                        static reconcileInputState(save: ReconcilliationEvent) { <div class="d-inline comment"><- save is one of the possibly many saved elements reconciled.</div>
                                            <br>
                                            
                                            let element = document.querySelector(save.selector) <div class="d-inline comment"><- Extract the element from the new DOM tree.</div>
                                            <br>
                                            
                                            if (element === null)
                                            <br>
                                            return _SM_Log.log(2, 'Cannot find element to reconcile - ' + save.selector)
                                            <br>
                                            
                                            if (save.wasFocused === 'true') {
                                                <br>
                                                (element as HTMLElement).focus()
                                                <br>
                                            }
                                            <br>
                                            <div class="d-inline comment"><- Re-add focus if it was focused before the render happened.</div>
                                            
                                            element.setSelectionRange(save.selectionStart, save.selectionEnd)
                                            <br>

                                        }
                                        <br>
                                        <br>

                                        While this works fine, its not very scalable to have to write such reconcilliation events for each type of DOM element you wish to preserve. 
                                    </code>
                                    </div>
                                </div>
                            </div>
                        </div>
                        Depending on your use-case, I would recommend not adding an '_sm' class to any ancestor of a
                        form unless reconciliation for elements inside is supported. <div
                            class="highlight-inline fw-bold">Whats great is that since Stateful Markup is opt-in for any
                            DOM tree, you can still use it anywhere else on the page.</div>

                        <!-- FIXME: Remove extra logs from debugger -->
                        <div class="display-5 py-4 heading">Common Mistakes & Debugging</div>
                        Stateful Markup also offers a debugging script to help highlight potential problematic code
                        patterns.
                        <br>
                        To use it, include the script under the StatefulMarkupClient script and use the <div
                            class="cond-2">SMDebugClient</div>
                        to call all the normal methods.
                        <br>
                        The debugger adds tests and logs to cover the following common issues:
                        <br>
                        <li>Nested subscribers</li>
                        <li>Events which are left unhandled</li>
                        <li>Variables that have been left uninitialized even after the first render pass</li>
                        <li>Subscribers with no reactive variables / constructs in them</li>
                        <li>Subscribers which are dynamically added but invisible to the framework</li>
                        <li>Unequal renders when re-doing a render with no changes (Similar to React's Strict Mode)</li>
                        <br>
                        The Debug Client adds better & more verbose logs grouped together and also shows which tests
                        were failed, along with remarks explaining why.
                        <br>
                        <img class="img border-3 rounded py-3" src="assets/dbg_result.png">
                        <br>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
</body>

</html>